Untyp e d Lamb da Calculus Notes
Yip eng Liu
Last up date d: Octob er 27, 2024
Contents
1. Basics  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1
1.1. Intr o duction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1
1.2. Syntax  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2
1.3. Scop e  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2
1.4. Evaluation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2
1.4.1. Beta Re duction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2
1.4.2. Alpha Conv ersion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
1.4.3. Eta Re duction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
1.4.4. Evaluation Strategy  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4
1.4.5. Op erational Semantics  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
2. Pr ogramming in Lamb da Calculus  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
2.1. Functions of mor e arguments  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
2.2. Chur ch Bo olean  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6
2.3. Pairs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6
2.4. Chur ch Numerals  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7
2.5. Re cursion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8
3. Refer ences  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10
1. Basics
Lamb da calculus is a formal system for e xpr essing computations. Untyp e d lamb da calculus, can b e se en
as a computation mo del alternativ e to T uring machines, in which all computation is r e duce d to function
application and abstraction. It is also a simple pr ogramming language use d widely as a cor e language in
many comple x pr ogramming language implementations. It is so simple y et p o w erful enough to e xpr ess
any computation as mathematical obje ct, in which pr op erties can b e pr o v e d easily . Extension to basic
lamb da calculus brings comple x featur e such as mutable r efer ence , e xception handling, and typ e system
etc.
1.1. Intr o duction
The ke y idea is that in lamb da calculus, e v er ything  is a function. Arguments passe d to functions ar e
function, and r esult r eturne d by a function is also function. For e xample , assuming that the language has
integer , if  e xpr ession, and r e cursion (those featur es can b e formulate d as functions, w e will se e!), then
factorial  can b e deï¬ne d as follo ws:
factorial = ğœ† ğ‘› . if ( ğ‘› = = 0 ) 1 ( ğ‘› âˆ— factorial ( ğ‘› âˆ’ 1 ) )
Mathematically , the factorial function is deï¬ne d as:
1 / 10

factorial ( ğ‘› ) = {1 if ğ‘› = 0
ğ‘› âˆ— factorial ( ğ‘› âˆ’ 1 ) otherwise
The abstraction, ğœ† ğ‘› . â€¦ , is the same as writing a function that takes an argument n  and r eturns the r esult
of the e xpr ession.
1.2. Syntax
The syntax of untyp e d lamb da calculus consists of only thr e e typ e of terms: a variable  ğ‘¥ , an abstraction  of
a variable  fr om a term ğ‘¡ , written as ğœ† ğ‘¥ . ğ‘¡ , and an application  of term a term ğ‘¡1  to another term ğ‘¡2 , written
as ğ‘¡1 ğ‘¡2 . Formally:
T erms Deï¬nition
ğ‘¡ â©´ ğ‘¥ ( variable )
| ğœ† ğ‘¥ . ğ‘¡ ( abstraction )
| ğ‘¡ ğ‘¡ ( application )
W e usually use ğ‘¡ , ğ‘  , ğ‘¢ , etc. to denote an arbitrar y term. Similarly , ğ‘¥ , ğ‘¦ , ğ‘§ , etc. ar e use d to denote arbitrar y
variables. Applications ar e left-asso ciativ e , so ğ‘¡ ğ‘  ğ‘¢  is the same as ( ( ğ‘¡ ğ‘  ) ğ‘¢ ) . Bo dy of abstraction is e x-
tende d as far as p ossible , as the r esult ğœ† ğ‘¥ . ğœ† ğ‘¦ . ğ‘¥ ğ‘¦  is the same as ğœ† ğ‘¥ . ( ğœ† ğ‘¦ . ( ğ‘¥ ğ‘¦ ) ) .
1.3. Scop e
An o ccurr ence of a variable ğ‘¥  in a term ğ‘¡  is said to b e b ound  if it is within the scop e of an abstraction 
ğœ† ğ‘¥ . ğ‘¡ . On the other hand, an o ccurr ence of a variable ğ‘¥  is said to b e fr e e  if it app ears in a term ğ‘¡  but is not
b ound. For e xample , o ccurr ences of ğ‘¥  in ğœ† ğ‘¦ . ğ‘¥  and ğ‘¥ ğ‘¦  ar e fr e e , while those in ğœ† ğ‘¥ . ğœ† ğ‘¦ . ( ğ‘¥ ğ‘¦ )  and ğœ† ğ‘¥ . ğ‘¥
ar e b ound. In ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘¥ , the ï¬rst o ccurr ence of ğ‘¥  is b ound, while the se cond is fr e e .
Fr e e V ariables Deï¬nition
The set of fr e e  variables of a term ğ‘¡  is denote d as FV ( ğ‘¡ ) :
FV ( ğ‘¥ ) = { ğ‘¥ }
FV ( ğœ† ğ‘¥ . ğ‘¡ ) = FV ( ğ‘¡ ) \ { ğ‘¥ }
FV ( ğ‘¡ ğ‘  ) = FV ( ğ‘¡ ) âˆª FV ( ğ‘  )
1.4. Evaluation
Pur e lamb da calculus do es not hav e constants or primitiv es â€“ w e can not p erform arithmetic op erations,
lo ops, or printing. The only thing w e can do is to apply functions to arguments.
1.4.1. Beta Re duction
W e call a term of the form ( ğœ† ğ‘¥ . ğ‘¡ ) ğ‘   a r e de x  (r e ducible e xpr ession), and the pr o cess of r eplacing the r e de x
with the r esult of the application is calle d b eta r e duction :
( ğœ† ğ‘¥ . ğ‘¡ ) ğ‘  âŸ¶ğ›½
[ ğ‘¥ â†¦ ğ‘  ] ğ‘¡
2 / 10

wher e [ ğ‘¥ â†¦ ğ‘  ] ğ‘¡  denotes the r esult of r eplacing all fr e e  o ccurr ences of ğ‘¥  in ğ‘¡  with ğ‘  . For e xample , ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘¦
e valuates to ğ‘¦ , and ( ğœ† ğ‘¥ . ğ‘¥ ( ğœ† ğ‘¥ . ğ‘¥ ) ) ğ‘   e valuates to ğ‘  ( ğœ† ğ‘¥ . ğ‘¥ ) . Formally , w e deï¬ne the captur e-av oiding
substitution as follo ws:
Substitution Deï¬nition
[ ğ‘¥ â†¦ ğ‘  ] ğ‘¥ = ğ‘ 
[ ğ‘¥ â†¦ ğ‘  ] ğ‘¦ = ğ‘¦ if ğ‘¥ â‰  ğ‘¦
[ ğ‘¥ â†¦ ğ‘  ] ( ğœ† ğ‘¦ . ğ‘¡ ) = ğœ† ğ‘¦ . [ ğ‘¥ â†¦ ğ‘  ] ğ‘¡ if ğ‘¦ â‰  ğ‘¥ and ğ‘¦ âˆ‰ FV ( ğ‘  )
[ ğ‘¥ â†¦ ğ‘  ] ( ğ‘¡ ğ‘¢ ) = [ ğ‘¥ â†¦ ğ‘  ] ğ‘¡ [ ğ‘¥ â†¦ ğ‘  ] ğ‘¢
1.4.2. Alpha Conv ersion
Consider ğœ† ğ‘¥ . ğ‘¥  and ğœ† ğ‘¦ . ğ‘¦  â€“ do the y r epr esent the same function? Y es! Although variable names ar e dif-
fer ent, the meaning of the terms ar e the same . W e say that tw o terms ar e alpha-e quivalent  if the y ar e the
same up to r enaming of b ound variables. And it is intuitiv e that variable names can b e change d without
changing the meaning of the term. This op eration is calle d alpha-conv ersion :
( ğœ† ğ‘¥ . ğ‘¡ ) âŸ¶ğ›¼( ğœ† ğ‘¦ . [ ğ‘¥ â†¦ ğ‘¦ ] ğ‘¡ ) if ğ‘¦ âˆ‰ FV ( ğ‘¡ )
wher e ğ‘¥  in the binder is r eplace d with ğ‘¦  in the b o dy of the abstraction.
Sometimes w e ne e d to r ename variables to av oid variable captur e in e valuation. For e xample , letâ€™s e val-
uate the follo wing term:
( ğœ† ğ‘¥ . ( ğœ† ğ‘¦ . ğ‘¥ ğ‘¦ ) ) ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¦ )
Notice that w e can not r eplace ğ‘¥  in the inner lamb da with ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¦ )  dir e ctly , b e cause ğ‘¦  is alr eady b ound
in the inner lamb da, but fr e e in the outer term. Then w e ne e d to do alpha-conv ersion , or r ename ğ‘¦  in the
inner lamb da to av oid variable captur e . Letâ€™s r ename ğ‘¦  to ğ‘§ . Then the term b e comes:
( ğœ† ğ‘¥ . ( ğœ† ğ‘¦ . ğ‘¥ ğ‘¦ ) ) ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¦ ) âŸ¶ğ›¼( ğœ† ğ‘¥ . ( ğœ† ğ‘§ . ğ‘¥ ğ‘§ ) ) ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¦ )
No w w e can do b eta r e duction, r eplacing ğ‘¥  in the inner lamb da with ğœ† ğ‘¥ . ğ‘¥ ğ‘¦ :
( ğœ† ğ‘¥ . ( ğœ† ğ‘§ . ğ‘¥ ğ‘§ ) ) ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¦ ) âŸ¶ğ›½
( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¦ ) ğ‘§ ) âŸ¶ğ›½
ğœ† ğ‘§ . ğ‘§ ğ‘¦
When picking ne w name for variables, w e ne e d to make sur e that the ne w variable name is not alr eady
use d in the term, i.e . it do es not captur e any fr e e variables in the term. For e xample , it is incorr e ct  to
r ename ğ‘¦  to ğ‘§  in ğœ† ğ‘§ . ğœ† ğ‘¦ . ( ğ‘§ ğ‘¦ ) , b e cause ğ‘§  is fr e e  in ( ğ‘§ ğ‘¦ ) .
1.4.3. Eta Re duction
Eta r e duction  captur es the natur e of function e xtensionality: tw o functions ar e e qual if the y giv e the same
r esult for all arguments. For e xample , ğœ† ğ‘¥ . ğ‘“ ğ‘¥  is the same as ğ‘“  if ğ‘¥  is not fr e e in ğ‘“ . Formally , w e deï¬ne eta
r e duction as:
ğœ† ğ‘¥ . ğ‘¡ ğ‘¥ âŸ¶ğœ‚
ğ‘¡ if ğ‘¥ âˆ‰ FV ( ğ‘¡ )
3 / 10

1.4.4. Evaluation Strategy
When e valuating a term, w e can cho ose diï¬€er ent strategies to p erform b eta r e duction, i.e . which r e de x
to r e duce ï¬rst. A term is str ongly normalizing  if e v er y r e duction se quence terminates in a normal form,
and w eakly normalizing  if ther e e xists a r e duction se quence that terminates in a normal form, but not all
r e duction se quences terminate . It has b e en pr o v en that in untyp e d lamb da calculus, normalizing terms
always hav e a unique normal form, but not all terms ar e normalizing. Thus, diï¬€er ent e valuation strategies
may lead to diï¬€er ent r esults. Letâ€™s consider se v eral e valuation strategies:
Full b eta r e duction Any r e de x can b e r e duce d at any time .
Consider the follo wing term, which has thr e e r e de xes:
( ğœ† ğ‘¥ . ğ‘¥ ) ( ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ ) )
( ğœ† ğ‘¥ . ğ‘¥ ) ( ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ ) )
( ğœ† ğ‘¥ . ğ‘¥ ) ( ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ ) )
W e can r e duce the innermost ï¬rst, and then do the middle one , and ï¬nally the outermost one:
( ğœ† ğ‘¥ . ğ‘¥ ) ( ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ ) ) âŸ¶ ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ )
âŸ¶ ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ğ‘§ )
âŸ¶ ğœ† ğ‘§ . ğ‘§
Normal or der r e duction Always r e duce the leftmost, outermost r e de x ï¬rst.
Letâ€™s do the same term with normal or der r e duction:
( ğœ† ğ‘¥ . ğ‘¥ ) ( ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ ) ) âŸ¶ ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ )
âŸ¶ ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§
âŸ¶ ğœ† ğ‘§ . ğ‘§
W e get the same r esult using diï¬€er ent r e duction se quences!
Call by name Do normal or der r e duction, but do not r e duce inside abstractions.
( ğœ† ğ‘¥ . ğ‘¥ ) ( ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ ) ) âŸ¶ ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ )
âŸ¶ ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§
This is the normal form! W e can not r e duce it further b e cause w e donâ€™t r e duce inside abstractions.
Call by value Only r e duce outermost r e de xes and a r e de x is r e duce d only when its right-hand side is
in normal form.
( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ ) âŸ¶ ( ğœ† ğ‘¥ . ğ‘¥ ) ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ )
âŸ¶ ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§
Note that w e can not r e duce further ( ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§ ) , the right-hand side after the ï¬rst step , as it is in
normal form. W e donâ€™t r e duce inside abstractions as in call by name . Call by value is strict in the sense
4 / 10

that arguments ar e e valuate d b efor e the function is applie d. Sometimes it fails to ï¬nd the normal form,
e v en if it e xists.
W e hav e se en that in call by name and call by name , ğœ† ğ‘§ . ( ğœ† ğ‘¥ . ğ‘¥ ) ğ‘§  is r egar de d as normal form, while ther e
is still a r e de x in it. On the other hand, in normal or der r e duction, since w e can r e duce the r e de x inside the
abstraction, w e get the normal form ğœ† ğ‘§ . ğ‘§ . If a term has b eta normal form (no b eta r e duction p ossible),
then normal or der r e duction will ï¬nd it. The term ab o v e e valuates to diï¬€er ent r esults dep ending on the
e valuation strategy , but e v entually the y all lead to the same normal form as the one yielde d by normal
or der r e duction after some r e ductions. This r enders Chur ch-Rosser the or em , or the conï¬‚uence pr op erty ,
which states that if a term can b e r e duce d to tw o diï¬€er ent normal forms, then those normal forms ar e
e quivalent up to alpha-conv ersion.
1.4.5. Op erational Semantics
Op erational semantics is a formal way to describ e ho w the e valuation of a term pr o ce e ds. Letâ€™s adopt call
by value e valuation strategy . W e can deï¬ne the e valuation r elation ğ‘¡ â†’ ğ‘¡â€²:
ğ‘¡1 âŸ¶ ğ‘¡â€²
1E-App1
ğ‘¡1 ğ‘¡2 âŸ¶ ğ‘¡â€²
1 ğ‘¡2
ğ‘¡2 âŸ¶ ğ‘¡â€²
2E-App2
ğ‘£1 ğ‘¡2 âŸ¶ ğ‘£1 ğ‘¡â€²
2
E-AppAbs
( ğœ† ğ‘¥ . ğ‘¡1 2 ) ğ‘£2 âŸ¶ [ ğ‘¥ â†¦ ğ‘£2 ] ğ‘¡1 2
ğ‘£  denotes a value , which is a term that cannot b e r e duce d further . In our case , a value is an abstraction 
ğœ† ğ‘¥ . ğ‘¡ . E-App1  applies to any application whose left-hand side is not a value , while E-App2  applies to any
application whose right-hand side is not a value . That means, E-App1  is always applie d b efor e E-App2  â€“
w e use E-App1  to r e duce ğ‘¡1  to a value , then use E-App2  to r e duce ğ‘¡2  to a value , and ï¬nally use E-AppAbs
to r e duce the application. The e valuation or der is determine d by the rules! If w e instead use call by name ,
w e can deï¬ne the e valuation r elation as follo ws:
ğ‘¡1 âŸ¶ ğ‘¡â€²
1E-App1
ğ‘¡1 ğ‘¡2 âŸ¶ ğ‘¡â€²
1 ğ‘¡2
E-AppAbs
( ğœ† ğ‘¥ . ğ‘¡1 2 ) ğ‘¡2 âŸ¶ [ ğ‘¥ â†¦ ğ‘¡2 ] ğ‘¡1 2
Can y ou se e the diï¬€er ence? In call by name , w e do not r e duce the right-hand side b efor e applying the
function. This is wher e lazy e valuation comes fr om! Mor e o v er , in E-AppAbs  w e no longer r e quir e the
right-hand side to b e a value .
2. Pr ogramming in Lamb da Calculus
No w that w e hav e a basic understanding of lamb da calculus, w e can start pr ogramming in it! W e will se e
ho w to deï¬ne various data structur es and functions using lamb da calculus.
2.1. Functions of mor e arguments
Obser v e that lamb da calculus only allo ws functions of one argument, but functions of mor e arguments
can b e obtaine d by curr ying . For e xample , a function of tw o arguments, ğ‘“ ( ğ‘¥ , ğ‘¦ ) , can b e r epr esente d as 
5 / 10

( ğœ† ğ‘¥ . ( ğœ† ğ‘¦ . ğ‘“ ğ‘¥ ğ‘¦ ) ) . Remo ving unne cessar y par entheses, w e can write it as ğœ† ğ‘¥ . ğœ† ğ‘¦ . ğ‘“ ğ‘¥ ğ‘¦ . A function tak-
ing tw o arguments is a function that takes one argument and r eturns a function that takes another ar-
gument!
2.2. Chur ch Bo olean
Bo olean values and conditionals can b e easily deï¬ne d in lamb da calculus. W e deï¬ne true  and false  as
follo ws:
true = ğœ† ğ‘¥ . ğœ† ğ‘¦ . ğ‘¥
false = ğœ† ğ‘¥ . ğœ† ğ‘¦ . ğ‘¦
And w e deï¬ne if  function as:
if = ğœ† ğ‘ . ğœ† ğ‘¥ . ğœ† ğ‘¦ . ğ‘ ğ‘¥ ğ‘¦
This function do es not do much: it just applies tw o arguments to the b o olean value . Letâ€™s se e ho w it w orks:
if true ğ‘¢ ğ‘£ = ( ğœ† ğ‘ . ğœ† ğ‘¥ . ğœ† ğ‘¦ . ğ‘ ğ‘¥ ğ‘¦ ) true ğ‘¢ ğ‘£
âŸ¶ ( ğœ† ğ‘¥ . ğœ† ğ‘¦ . true ğ‘¥ ğ‘¦ ) ğ‘¢ ğ‘£
âŸ¶ ( ğœ† ğ‘¦ . true ğ‘¢ ğ‘¦ ) ğ‘£
âŸ¶ true ğ‘¢ ğ‘£
= ( ğœ† ğ‘¥ . ğœ† ğ‘¦ . ğ‘¥ ) ğ‘¢ ğ‘£
âŸ¶ ( ğœ† ğ‘¦ . ğ‘¢ ) ğ‘£
âŸ¶ ğ‘¢
if true ğ‘¢ ğ‘£  e valuates to ğ‘¢ ! Similarly , w e can deï¬ne other b o olean functions:
and = ğœ† ğ‘ . ğœ† ğ‘ . ğ‘ ğ‘ false
or = ğœ† ğ‘ . ğœ† ğ‘ . ğ‘ true ğ‘
not = ğœ† ğ‘ . ğ‘ false true
Those deï¬nitions ar e not unique , and w e can deï¬ne them in many ways. The insight her e is that a chur ch
b o olean is a function that takes tw o arguments and r eturns one of them â€“ true  r eturns the ï¬rst argument,
and false  r eturns the se cond argument. K e eping this in mind, it is easy to se e that why the ab o v e deï¬-
nitions make sense . For e xample , the function and , takes tw o b o olean values ğ‘  and ğ‘ , and r eturns ğ‘  if ğ‘
is true , and false  other wise . Thus, it r eturns true  if b oth ğ‘  and ğ‘  ar e true , and false  if either of them
is false .
2.3. Pairs
Using b o olean, w e can deï¬ne pairs as w ell.
pair = ğœ† ğ‘“ . ğœ† ğ‘  . ğœ† ğ‘ . ğ‘ ğ‘“ ğ‘ 
fst = ğœ† ğ‘ . ğ‘ true
snd = ğœ† ğ‘ . ğ‘ false
Let ğ‘ = pair ğ‘¢ ğ‘£ , then fst ğ‘  e valuates to ğ‘¢ , and snd ğ‘  e valuates to ğ‘£ . Letâ€™s tr y:
6 / 10

fst ( pair ğ‘¢ ğ‘£ ) = fst ( ( ğœ† ğ‘“ . ğœ† ğ‘  . ğœ† ğ‘ . ğ‘ ğ‘“ ğ‘  ) ğ‘¢ ğ‘£ )
âŸ¶ fst ( ( ğœ† ğ‘  . ğœ† ğ‘ . ğ‘ ğ‘¢ ğ‘  ) ğ‘£ )
âŸ¶ fst ( ğœ† ğ‘ . ğ‘ ğ‘¢ ğ‘£ )
= ( ğœ† ğ‘ . ğ‘ true ) ( ğœ† ğ‘ . ğ‘ ğ‘¢ ğ‘£ )
âŸ¶ ( ğœ† ğ‘ . ğ‘ ğ‘¢ ğ‘£ ) true
âŸ¶ true ğ‘¢ ğ‘£
âŸ¶âˆ—ğ‘¢
Do y ou se e ho w the deï¬nition of b o olean helps us to deï¬ne pairs?
2.4. Chur ch Numerals
Natural numb ers can b e r epr esente d in lamb da calculus as Chur ch numerals :
ğ‘0 = ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘¥
ğ‘1 = ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ğ‘¥
ğ‘2 = ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ( ğ‘“ ğ‘¥ )
ğ‘3 = ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ( ğ‘“ ( ğ‘“ ğ‘¥ ) )
â€¦
ğ‘ğ‘› = ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ğ‘›ğ‘¥
A Chur ch numeral ğ‘ğ‘›  is a function that takes tw o arguments, a function ğ‘“  and a value ğ‘¥ , and applies ğ‘“
to ğ‘¥  ğ‘›  times. For e xample , ğ‘2  is a function that takes a function ğ‘“  and a value ğ‘¥ , and applies ğ‘“  to ğ‘¥  twice .
Successor
W e deï¬ne the successor function as:
succ = ğœ† ğ‘› . ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ( ğ‘› ğ‘“ ğ‘¥ )
It takes a Chur ch numeral ğ‘›  and r eturns another Chur ch numeral that r epr esents the successor of ğ‘› , i.e .
applying ğ‘“  to ğ‘¥  one mor e time than ğ‘›  do es. Letâ€™s tr y succ ğ‘2 :
succ ğ‘2 = ( ğœ† ğ‘› . ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ( ğ‘› ğ‘“ ğ‘¥ ) ) ğ‘2
âŸ¶ ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ( ğ‘2 ğ‘“ ğ‘¥ )
âŸ¶ ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ( ( ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ( ğ‘“ ğ‘¥ ) ) ğ‘“ ğ‘¥ )
âŸ¶ ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ( ( ğœ† ğ‘¥ . ğ‘“ ( ğ‘“ ğ‘¥ ) ) ğ‘¥ )
âŸ¶ ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘“ ( ğ‘“ ( ğ‘“ ğ‘¥ ) )
= ğ‘3
A ddition
Then w e deï¬ne addition:
plus = ğœ† ğ‘š . ğœ† ğ‘› . ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘š ğ‘“ ( ğ‘› ğ‘“ ğ‘¥ )
7 / 10

It takes tw o Chur ch numerals ğ‘š  and ğ‘› , and r eturns another Chur ch numeral that r epr esents the sum of
ğ‘š  and ğ‘› . If w e had ( ğ‘š ğ‘“ ğ‘¥ ) , it w ould apply ğ‘“  to ğ‘¥  ğ‘š  times. No w w e hav e ( ğ‘š ğ‘“ ( ğ‘› ğ‘“ ğ‘¥ ) ) , which applies
ğ‘“  to ( ğ‘› ğ‘“ ğ‘¥ )  ğ‘š  times, wher e ( ğ‘› ğ‘“ ğ‘¥ )  applies ğ‘“  to ğ‘¥  ğ‘›  times. Thus, it applies ğ‘“  to ğ‘¥  ğ‘š + ğ‘›  times!
Multiplication
What ab out multiplication?
times = ğœ† ğ‘š . ğœ† ğ‘› . ğ‘š ( plus ğ‘› ) ğ‘0
Her e w e use another trick: plus ğ‘›  is a function that takes Chur ch numeral ğ‘š  and r eturns ğ‘š + ğ‘› . Passing
it as the ï¬rst argument to ğ‘š  will apply it ğ‘š  times on ğ‘0  â€“ that is, it will add ğ‘›  to 0  ğ‘š  times, which is ğ‘š âˆ—
ğ‘› . alternativ ely , w e can deï¬ne multiplication as:
times = ğœ† ğ‘š . ğœ† ğ‘› . ğœ† ğ‘“ . ğœ† ğ‘¥ . ğ‘š ( ğ‘› ğ‘“ ) ğ‘¥
Can y ou se e the similarity b etw e en the tw o deï¬nitions?
Exp onentiation
For ğ‘šğ‘›, w e deï¬ne:
exp = ğœ† ğ‘š . ğœ† ğ‘› . ğ‘› ğ‘š
A v er y short deï¬nition that lo oks w eir d. T o se e ho w it w orks, letâ€™s supp ose ğ‘›  is a Chur ch numeral. Then
w e hav e
ğ‘› ğ‘“ ğ‘¥ = ğ‘“ğ‘›ğ‘¥
ğ‘› ğ‘“ = ğ‘“ğ‘›( ğœ‚ -reduction )
Letâ€™s r eplace ğ‘“  with ğ‘š :
ğ‘› ğ‘š = ğ‘šğ‘›
W e disco v er that ğ‘› ğ‘š  is the same as ğ‘šğ‘›! Thus our deï¬nition do es the right thing.
Pr e de cessor
Surprisingly , pr e de cessor is the har dest function to deï¬ne . It is not clear ho w to r emo v e one application
of ğ‘“  fr om ğ‘¥ . One trick is to use a pair of numb ers ( ğ‘› âˆ’ 1 , ğ‘› )  to r epr esent ğ‘› , and then w e can e xtract the
pr e de cessor fr om the pair .
zz = pair ğ‘0 ğ‘0
ss = ğœ† ğ‘ . pair ( snd ğ‘ ) ( succ ( snd ğ‘ ) )
pred = ğœ† ğ‘› . fst ( ğ‘› ss zz )
When ss  is applie d to a pair , it r eturns a pair of the se cond element of the pair and the successor of the
se cond element. Thus, ss  is a function that takes a pair ( ğ‘› âˆ’ 1 , ğ‘› )  and r eturns ( ğ‘› , ğ‘› + 1 ) . Then, pred  takes
a Chur ch numeral ğ‘›  and r eturns the ï¬rst element of the pair ( ğ‘› âˆ’ 1 , ğ‘› ) , which is ğ‘› âˆ’ 1 .
2.5. Re cursion
Ther e is no built-in r e cursion in lamb da calculus, b e cause when deï¬ning a term, w e can not r efer itself
in its b o dy . If w e do not hav e e xpr ess lo op/r e cursion in a language , then the language can not e xpr ess
8 / 10

any computation. Her e in untyp e d lamb da calculus, w e can deï¬ne r e cursiv e functions using ï¬xe d-p oint
combinators.
Re call that in untyp e d lamb da calculus, some terms ar e not normalizing, i.e . the y do not hav e a normal
form. Consider the follo wing term calle d the Omega combinator :
Î© = ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¥ ) ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¥ )
It has only one r e de x, and it r e duces to itself:
( ğœ† ğ‘¥ . ğ‘¥ ğ‘¥ ) ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¥ ) âŸ¶ ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¥ ) ( ğœ† ğ‘¥ . ğ‘¥ ğ‘¥ )
No matter ho w many times w e apply b eta r e duction, w e will ne v er r each a normal form. Letâ€™s consider
another term calle d the Y combinator :
ğ‘Œ = ğœ† ğ‘“ . ( ğœ† ğ‘¥ . ğ‘“ ( ğ‘¥ ğ‘¥ ) ) ( ğœ† ğ‘¥ . ğ‘“ ( ğ‘¥ ğ‘¥ ) )
It is har d to se e what this term do es by lo oking at its deï¬nition. It is also calle d ï¬xe d-p oint combinator ,
and it can b e use d to deï¬ne r e cursiv e functions in lamb da calculus. Letâ€™s tr y applying ğ‘Œ  to some function
ğ‘” :
ğ‘Œ ğ‘” = ( ğœ† ğ‘“ . ( ğœ† ğ‘¥ . ğ‘“ ( ğ‘¥ ğ‘¥ ) ) ( ğœ† ğ‘¥ . ğ‘“ ( ğ‘¥ ğ‘¥ ) ) ) ğ‘”
âŸ¶ ( ğœ† ğ‘¥ . ğ‘” ( ğ‘¥ ğ‘¥ ) ) ( ğœ† ğ‘¥ . ğ‘” ( ğ‘¥ ğ‘¥ ) )
âŸ¶ ğ‘” ( ğœ† ğ‘¥ . ğ‘” ( ğ‘¥ ğ‘¥ ) ) ( ğœ† ğ‘¥ . ğ‘” ( ğ‘¥ ğ‘¥ ) )
= ğ‘” ( ğ‘Œ ğ‘” )
ğ‘Œ ğ‘”  e valuates to ğ‘” ( ğ‘Œ ğ‘” ) ! Ho w e v er , in the setting of call by value , ğ‘Œ ğ‘”  div erges b e cause it tries to e valuate
ğ‘Œ ğ‘”  b efor e applying ğ‘”  to it. Ther e is another ï¬xe d-p oint combinator calle d the Z combinator  that w orks
in call by value:
ğ‘ = ğœ† ğ‘“ . ( ğœ† ğ‘¥ . ğ‘“ ( ğœ† ğ‘¦ . ğ‘¥ ğ‘¥ ğ‘¦ ) ) ( ğœ† ğ‘¥ . ğ‘“ ( ğœ† ğ‘¦ . ğ‘¥ ğ‘¥ ğ‘¦ ) )
A ctually it is an eta e xpansion of ğ‘Œ , and b e cause of the argument ğ‘£ , ğ‘ ğ‘”  in the right-hand side will not
b e e valuate d eagerly in call by value language . Letâ€™s se e ho w it w orks:
ğ‘ ğ‘” ğ‘£ = ( ğœ† ğ‘“ . ( ğœ† ğ‘¥ . ğ‘“ ( ğœ† ğ‘¦ . ğ‘¥ ğ‘¥ ğ‘¦ ) ) ( ğœ† ğ‘¥ . ğ‘“ ( ğœ† ğ‘¦ . ğ‘¥ ğ‘¥ ğ‘¦ ) ) ) ğ‘” ğ‘£
âŸ¶ ( ğœ† ğ‘¥ . ğ‘” ( ğœ† ğ‘¦ . ğ‘¥ ğ‘¥ ğ‘¦ ) ) ( ğœ† ğ‘¥ . ğ‘” ( ğœ† ğ‘¦ . ğ‘¥ ğ‘¥ ğ‘¦ ) ) ğ‘£
âŸ¶ ğ‘” ( ğœ† ğ‘¦ . ( ğœ† ğ‘¥ . ğ‘” ( ğœ† ğ‘˜ . ğ‘¥ ğ‘¥ ğ‘˜ ) ) ( ğœ† ğ‘¥ . ğ‘” ( ğœ† ğ‘˜ . ğ‘¥ ğ‘¥ ğ‘˜ ) ) ğ‘¦ ) ğ‘£
âŸ¶ğœ‚
ğ‘” ( ğœ† ğ‘¥ . ğ‘” ( ğœ† ğ‘˜ . ğ‘¥ ğ‘¥ ğ‘˜ ) ) ( ğœ† ğ‘¥ . ğ‘” ( ğœ† ğ‘˜ . ğ‘¥ ğ‘¥ ğ‘˜ ) ) ğ‘£
= ğ‘” ( ğ‘ ğ‘” ) ğ‘£
It b ehav es the same way as ğ‘Œ ğ‘” . In r eal w orld pr ogramming languages, ï¬xe d p oint combinators ar e usually
calle d fix . T o deï¬ne a r e cursiv e function, ï¬rst w e deï¬ne a function ğ‘” = ğœ† ğ‘“ . â€¦  wher e the b o dy contains
a r efer ence to ğ‘“ , and then w e apply fix  to ğ‘”  to get the r e cursiv e function. For e xample , to deï¬ne the
factorial function, w e can deï¬ne ğ‘”  as:
ğ‘” = ğœ† ğ‘“ . ğœ† ğ‘› . if ( ğ‘› = = ğ‘0 ) then ğ‘1 else ( ğ‘› âˆ— ğ‘“ ( ğ‘› âˆ’ 1 ) )
factorial = fix ğ‘”
9 / 10

assuming that w e hav e the multiplication, subtraction, e quality , and if e xpr ession. No w w e gaine d the
ability to deï¬ne r e cursiv e functions in lamb da calculus!
3. Refer ences
â€¢ Pier ce , B. C. (2002). T yp es and Pr ogramming Languages
â€¢ Felleisen, M., & F latt, M. (2006). Pr ogramming Languages and Lamb da Calculi
10 / 10