CMPSC 461, Fall 2025
Programming Language Concepts
Instructor: Dr. Suman Saha
Midterm-I Practice Exam Solutions
General Instructions about Midterm-I:
Exam Date: September 29, 2025
Exam Time: 8:10 PM - 10:00 PM
1. If you have any conflict, you are requested to contact the instructor at least 72 hours1
before the exam and inform them about it.
2. If you are someone who requires any special accommodations, please reach out to the in-
structor at least 72 hours before the exam and inform them of your requirements, in order
to accommodate well in advance.
3. If you are sick or unfit and are prescribed rest or quarantine by the medical authorities during
the exam hours, we request you to kindly inform the instructor with the relevant paperwork.
4. Kindly arrive at the exam hall 10-15 minutes before the scheduled time to settle yourself
in and follow the instructions for seating (if any). You will have the seating plan informed
to you 36 hours before the exam schedule.
5. It is mandatory to carry Penn State Student ID (Physical/ Mobile ID+) to the exam
hall. No other ID(s) will be accepted for verifying your submission.
6. This exam will be a closed book and closed note with no cheat sheets permitted .
7.No electronic devices are allowed on the desk while taking the exam. You should only
have your writing instruments and the exam paper on your desk while working on the exam.
8. Make sure your writing instruments are high contrast (this is required for better scan-
ning of your submissions on Gradescope).
9. If you have any questions during the exam, kindly raise your hand and one of the proctors
will reach out to you.
10. Any violations will lead to direct consequences as per the course’s academic integrity policies.
11. As per Penn State policy, most campus areas no longer require masks, with a few exceptions.
For safety amidst rising COVID cases, if you choose to wear a mask, we support you but
remember to verify your identity (without the mask) when submitting your exam copy.
All the very best for Midterm :)
1unless it’s an emergency- in that case, an exception will be made based on the severity of the situation.

Problem 1: Regular Expressions I
1. Construct a regular expression for URLs that:
•Must begin with http:// orhttps:// .
•Domain must be letters only, 2–10 in length.
•Must end with one of the extensions: .com,.org, or.net.
Valid:
http://psu.com
https://example.org
https://abc.net
Invalid:
http://psu.edu – extension not allowed
https://1abc.com – domain contains a digit
2. Construct a regular expression for time in 12-hour format HH:MMAM orHH:MMPM where:
•HHranges from 01 to 12.
•MMranges from 00 to 59.
•The string must end with either AMorPM.
Valid:
01:00AM
12:45PM
09:59PM
Invalid:
00:15AM – hour cannot be 00
13:00PM – hour cannot exceed 12
7:30AM– hour must be two digits
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 1/14

3. Construct a regular expression over Σ ={a,b,c}for strings where the first and last symbols
are different, and the string length is at least 3.
Valid:
abc
bac
cbbba
Invalid:
aa– too short and same start/end
cb– too short
cacac– starts and ends with same symbol
Solution
1.https?://[a-zA-Z]{2,10}\.(com|org|net)
2.(0[1-9]|1[0-2]):[0-5][0-9](AM|PM)
3.a[abc]+(b|c)|b[abc]+(a|c)|c[abc]+(a|b)
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 2/14

Problem 2: Finite Automata I
1. Design a DFA recognizing the string over the alphabet {1,2,3}where the string starts with
a single 3followed by 1or2.
For example, accepted strings: 31,32,31231,313323; rejected strings: ϵ,3,33,123.
Draw the graph clearly with states and transitions. Mark the start state and all accepting
state(s). No explanation required. No transition table required.
2. Design a NFA recognizing the string over the alphabet {a,b,c}where the string has consec-
utiveas.
For example, accepted strings: aab,baaac,aabb,abccaaa; rejected strings: ϵ,a,aba,caba.
Draw the graph clearly with states and transitions. Mark the start state and all accepting
state(s). No explanation required. No transition table required.
3. Convert the following NFA transition table into equivalent DFA transition table using subset
construction.
Only DFA transition table is required. No Automata graph required. No explanation re-
quired. Also, mention the start state and all accepting state(s) in the derived DFA. You can
omit the row if no transitions going out from the state or it cannot be reached from the start
state.
NFA State xyz
q0{q1,q2}{q0}{q2}
q1{q2}{q1}ϕ
q2ϕ{q0,q2}{q1}
The start state is q0, and the accepting state is q2.
Solution
1. One correct DFA is shown below:
q0 q1 q23 1, 21, 2, 3
2. One correct NFA is shown below:
q0 q1 q2a, b, c
a aa, b, c
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 3/14

3. The transition table is shown below:
DFA State xyz
q0q1q2q0q2
q1q2q2q0q1q2q1
q2ϵq0q2q1
q0q1q2q1q2q0q1q2q1q2
q1q2q1ϵ
q0q2q1q2q0q2q1q2
The start state is q0, and the accepting states are q1q2,q2,q0q1q2, andq0q2.
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 4/14

Problem 3: Finite Automata II
1. Given the regular expression " a(ab|cb)∗" over the alphabet Σ ={a,b,c}, build an equivalent
DFA.
Note: Draw the graph clearly with states and transitions. Mark the start state and all accepting
state(s). No explanation required. No transition table required.
Solution
q0 q1 q2
q3a a
b
cb
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 5/14

Problem 4: Context Free Grammar - I
Consider the grammar:
1.L={w∈{0,1}∗|wstarts with 0 and ends with 1 }. Some valid strings are 01, 001, 0111,
000011111, etc.
(a) Provide CFG for the language mentioned above.
(b) Using grammar generated in part a), provide the left-most derivation for string 0011.
2.L={anb2n|n≥1}. Some valid strings in the language are ab, aabbbb, aaabbbbbb, etc.
(a) Provide a CFG for the language.
Solution
1. (a)
S→0A1
A→0A|1A|ϵ
(b)S⇒0A1⇒00A1⇒001A1⇒001ϵ1 = 0011
2.
S→aSbb|abb
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 6/14

Problem 5: Context Free Grammar - II
1. (True or False): All regular grammars are also context-free grammars, but not all context-
free grammars are regular. Explain your answer clearly.
2. Briefly explain the four components of a context-free grammar (CFG). Give an example
production rule for illustration.
Solution
1. True. Regular grammars are a strict subset of context-free grammars. While every regular
grammar can be expressed as a CFG, many CFGs (such as those for balanced parentheses)
cannot be represented by regular grammars.
2. A context-free grammar is defined by a 4-tuple G= (V,Σ,R,S ):
•V(Variables / Non-terminals): Symbols that can be replaced (e.g., E,T).
•Σ(Terminals): Actual symbols of the language (e.g., id,+,∗).
•R(Rules / Productions): Rewriting rules of the form A→αwhereAis a non-terminal
andαis a string of terminals/non-terminals (or ϵ).
•S(Start symbol): A distinguished non-terminal from which derivations begin.
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 7/14

Problem 6: Ambiguity - I
Convert each of the following regular expressions into an equivalent CFG using BNF notation. Your
grammar should be unambiguous and use a minimal number of production rules. To abbreviate
ranges of consecutive characters, you can use the syntax a|···|z.
1.<[1-9][0-9]+(:[0-9][0-9]+)*>
Matches strings like <10>and<1234:567> and<12:345:6789> but not <01>or<1234:56>
or<9876:>
2.(0|[1-9][0-9]*)+(0|[1-9][0-9]*)(\.(0|[0-9]*[1-9]))?
Matches strings like 0+0and123+456.7 and0.123+456.007 but not 1.2+456 or01+123or
123+456.700
Solution
1.S→<D1D0N0N1>
N0→D0N0|ϵ
N1→:D0N0N1|ϵ
D0→0|···| 9
D1→1|···| 9
2.S→N0+N0N1
N0→0|D1Dn
N1→.DnD1|ϵ
Dn→D0Dn|ϵ
D0→0|···| 9
D1→1|···| 9
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 8/14

Problem 7: Ambiguity - II
In Python, functions are declared using the defkeyword, a function name, and a pair of
parentheses containing a parameter list . This list contains zero or more variable names followed by
zero or more variables with default values. This parameter list can be expressed using the following
CFG:
S→X,Y|X|Y|ϵ
X→X,X|⟨var⟩
Y→Y,Y|⟨var⟩=⟨expr⟩
This grammar matches inputs like var 1,var 2=expr2but rejects inputs like var 1=expr1,var 2.
1. Show that the grammar is ambiguous using left-most derivation and the smallest possible
example. Clearly indicate which rule is being applied at each step.
2. The Dangling Else Problem showed that ambiguity can change the structure of a program.
Does this grammar cause the same issue? Why or why not?
Solution
1. The grammar is ambiguous for three or more parameters of a single kind. ⟨var⟩,⟨var⟩,⟨var⟩
and⟨var⟩=⟨expr⟩,⟨var⟩=⟨expr⟩,⟨var⟩=⟨expr⟩are functionally equivalent, so only the
former is shown below:
S S→X
X X→X, X
X, X X→X, X
X, X, X X→⟨var⟩
⟨var⟩, X, X X→⟨var⟩
⟨var⟩,⟨var⟩, X X→⟨var⟩
(a) First DerivationS S→X
X X→X, X
X, X X→⟨var⟩
⟨var⟩, X X→X, X
⟨var⟩, X, X X→⟨var⟩
⟨var⟩,⟨var⟩, X X→⟨var⟩
(b) Second Derivation
2.No, the ambiguity would not change the structure of a program. The differences between
the derivations would not cause the precedence of the parsed symbols to change.
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 9/14

Problem 8: Names, Scopes and Bindings I
Consider the following pseudo-code:
1int x = 100;
2
3v o i d helper () {
4 print (x);
5}
6
7v o i d recur ( int n) {
8 if(n > 0) {
9 int x = n;
10 recur (n - 1);
11 }e l s e {
12 helper ();
13 }
14}
15
16v o i d caller () {
17 int x = 50;
18 recur (2);
19}
20
21v o i d main () {
22 caller ();
23}
(a) Draw a diagram of the runtime stack at the exact moment the helper() function is called.
For each activation frame, clearly label its static link anddynamic link .
(b) What is the output of this program, assuming the language uses:
i. Static scoping?
ii. Dynamic scoping?
Solution
(a)Runtime Stack at helper() call
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 10/14

helper()
recur(0)
recur(1)
local x=1
recur(2)
local x=2
caller()
local x=50
Main()Static Links
Dynamic Links
(b)Program Outputs
i. Static scoping: 100
ii. Dynamic scoping: 1
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 11/14

Problem 9: Name, Scope, and Binding II
Consider the following pseudo-code:
1t y p e d e f vo i d (* FuncPtr )();
2
3v o i d worker () {
4 print (val );
5}
6
7FuncPtr setup () {
8 int val = 50;
9 r e t u r n worker ;
10}
11
12v o i d recursive_executor ( int n, FuncPtr F) {
13 if(n > 0) {
14 int val = n * 10;
15 recursive_executor (n - 1, F);
16 }e l s e {
17 F();
18 }
19}
20
21v o i d main () {
22 FuncPtr my_func ;
23 my_func = setup ();
24 recursive_executor (2, my_func );
25}
(A)Draw the symbol tables for the scopes global,worker,setup, and recursive_executor .
(B)What is the output if the language uses shallow binding ? Justify by tracing variable
resolution from the call site.
(C)What is the output if the language uses deep binding ? Explain which referencing environ-
ment is captured when the function reference is created.
Solution
(A) Symbol Tables
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 12/14

global
name kind
worker func
setup func
recurs
ive_executor func
main funcworker
name kind
setup
name kind
val idrecursive_executor
name kind
n para
F para
(func)
val id
(B) Shallow binding output: 10.
Explanation: Shallow binding resolves variables using the environment of the call site .
The call ‘F()‘ happens inside ‘recursive_executor(0)‘. The call stack is ‘main - >
recursive_executor(2) - >
recursive_executor(1) - >
recursive_executor(0) - >
worker‘.
The search for ‘val‘ begins up this dynamic chain:
it checks ‘worker‘ (none),
then its caller ‘recursive_executor(0)‘ (none),
and then its caller’s caller, ‘recursive_executor(1)‘, where it finds the local ‘val = 1 * 10 =
10‘.
(C) Deep binding output: 50.
Explanation: Deepbindingresolvesvariablesusingtheenvironmentfromwhenthefunction
reference was created. The reference to ‘worker‘ is returned by ‘setup()‘. At that moment,
a closure is created, capturing the environment of ‘setup()‘, which includes the binding ‘val
= 50‘. When ‘worker‘ is later called, it uses this captured environment to find ‘val‘, printing
‘50‘.
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 13/14

Problem 10: LL(1) Parsers
Consider the grammar:
S→A B
A→a A |
B→b B | c
(a) Compute the FIRST andFOLLOW sets forS,A,B.
(b) Construct the LL(1) parsing table and state whether the grammar is LL(1).
Solution
•FIRST sets: FIRST (A) ={a,ϵ},FIRST (B) ={b,c},FIRST (S) ={a,b,c}.
•FOLLOW sets: FOLLOW (S) ={$},FOLLOW (A) ={b,c},FOLLOW (B) ={$}.
•Parsing table:
Non-terminal a b c$
SS→ABS→ABS→AB
AA→aAA→ϵA→ϵ
B B→bBB→c
No conflicts⇒Grammar is LL(1).
CMPSC461, Fall-2025 |Practice Midterm-I Solutions 14/14