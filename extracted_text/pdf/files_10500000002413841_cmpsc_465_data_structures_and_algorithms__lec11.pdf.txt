CMPSC 465: LECTURE XI
DFS on Undirected Graphs
Ke Chen
September 24, 2025

Connected component
Recall that the connected component of an undirected graph is
dened as a maximal set of connected vertices.
A B C D I J
E F G H KIFinding the connected components helps answer queries like
\is node vconnected to node w?".
IHow? Just explore!
1 / 8

Connected component
Recall that the connected component of an undirected graph is
dened as a maximal set of connected vertices.
A B C D I J
E F G H K
IFinding the connected components helps answer queries like
\is node vconnected to node w?".IHow?Just explore!
1 / 8

Connected component
Recall that the connected component of an undirected graph is
dened as a maximal set of connected vertices.
A B C D I J
E F G H K
IFinding the connected components helps answer queries like
\is node vconnected to node w?".
IHow?Just explore!
1 / 8

Connected component
Recall that the connected component of an undirected graph is
dened as a maximal set of connected vertices.
A B C D I J
E F G H K
IFinding the connected components helps answer queries like
\is node vconnected to node w?".
IHow?Just explore!
1 / 8

Connected component
Recall that the connected component of an undirected graph is
dened as a maximal set of connected vertices.
A B C D I J
E F G H K
IFinding the connected components helps answer queries like
\is node vconnected to node w?".
IHow? Just explore!
1 / 8

Explore by Depth First Search (DFS)
Intuition Explore a maze with a chalk and a string.
The Fastest Maze-Solving Competition On Earth by Veritasium
2 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.Example
A0
B0
F0
E
0C
0D
0G
0
stack
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stackA
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stackA1
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stackA1
A
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
AE
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
AE
1
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stackA1
1
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stackA1
A
1
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1C
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1C
1
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1C
1C
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1 1CD
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1 1CD
1
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1 1CD
1D
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1 1C
1DB
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1 1C
1DB1
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1 1CD
11
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stack1
A
1C
1 11
3 / 8

Explore by Depth First Search (DFS)
DFS on a graph follows the same idea:
IThe graph is the maze, with vertices corresponding to intersections.
IInteger array (one int per vertex) as the colored cyber-chalk.
IString can be modeled by a stack , to backtrack we pop from the
stack.
Example
A0
B0
F0
E
0C
0D
0G
0
stackA1
1 1 11
3 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color// visited is an array of length jVj, filled with 0's
Explore( G,s,color )visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
Correctness?
s v1 0x1 last
y0
4 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color
// visited is an array of length jVj, filled with 0's
Explore( G,s,color )visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
Correctness?
s v1 0x1 last
y0
4 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color
// visited is an array of length jVj, filled with 0's
Explore( G,s,color )
visited [s] =colorforeach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
Correctness?
s v1 0x1 last
y0
4 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color
// visited is an array of length jVj, filled with 0's
Explore( G,s,color )
visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )Correctness?
s v1 0x1 last
y0
4 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color
// visited is an array of length jVj, filled with 0's
Explore( G,s,color )
visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
Correctness?s v1 0x1 last
y0
4 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color
// visited is an array of length jVj, filled with 0's
Explore( G,s,color )
visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
Correctness?s v1 0x1 last
y0
4 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color
// visited is an array of length jVj, filled with 0's
Explore( G,s,color )
visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
Correctness?
s v1 0x1 last
y0
4 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color
// visited is an array of length jVj, filled with 0's
Explore( G,s,color )
visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
Correctness?
s v1 0
x1 lasty0
4 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color
// visited is an array of length jVj, filled with 0's
Explore( G,s,color )
visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
Correctness?
s v1 0
x1 last
y0
4 / 8

Explore by Depth First Search (DFS)
Input: Graph G= (V; E), starting vertex s, chalk color
Output: Mark all nodes reachable from swith color
// visited is an array of length jVj, filled with 0's
Explore( G,s,color )
visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
Correctness?
s v1 0
x1 last
y0
4 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Example
a0
b0
c0
d0
i0
j0
e
0f
0g
0h
0k
0
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Example
a0
b0
c0
d0
i0
j0
e
0f
0g
0h
0k
0Explore( G,a,1)
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Example
a0
b0
c0
d0
i0
j0
e
0f
0g
0h
0k
0Explore( G,a,1)
1
1 1
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Example
a0
b0
c0
d0
i0
j0
e
0f
0g
0h
0k
0Explore( G,b,2)
1
1 1
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Example
a0
b0
c0
d0
i0
j0
e
0f
0g
0h
0k
0Explore( G,b,2)
1
1 12
2 2
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Example
a0
b0
c0
d0
i0
j0
e
0f
0g
0h
0k
0Explore( G,c,3)
1
1 12
2 2
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Example
a0
b0
c0
d0
i0
j0
e
0f
0g
0h
0k
0Explore( G,c,3)
1
1 12
2 23 3
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Example
a0
b0
c0
d0
i0
j0
e
0f
0g
0h
0k
0Explore( G,i,4)
1
1 12
2 23 3
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Example
a0
b0
c0
d0
i0
j0
e
0f
0g
0h
0k
0Explore( G,i,4)
1
1 12
2 23 3 4 4
4
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Time complexity?Explore is called on each vertex in V.
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Time complexity?
Explore is called on each vertex in V.
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Time complexity?
Explore is called on each vertex in V.
Ginadjacency matrix representation:IExplore checks all neighbors of a vertex.
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Time complexity?
Explore is called on each vertex in V.
Ginadjacency matrix representation:
IExplore checks all neighbors of a vertex.
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Time complexity?
Explore is called on each vertex in V.
Ginadjacency matrix representation:
IExplore checks all neighbors of a vertex.O 
jVj2
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Time complexity?
Explore is called on each vertex in V.
Ginadjacency list representation:IExplore checks each edge twice.
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Time complexity?
Explore is called on each vertex in V.
Ginadjacency list representation:
IExplore checks each edge twice.
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Time complexity?
Explore is called on each vertex in V.
Ginadjacency list representation:
IExplore checks each edge twice.O(jVj+jEj)
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Can we do better?O(jVj+jEj)is the best possible, since we need to read the graph.
5 / 8

The Depth First Search (DFS) algorithm
I The Explore procedure reveals one connected component.
I DFS works by repeatedly calling Explore.
DFS(G= (V; E))
visited is an array of length jVj, lled with 0's
color = 1
foreach s2Vdo
ifvisited [s] == 0 then
Explore( G,s,color )
color =color + 1
Can we do better?
O(jVj+jEj)is the best possible, since we need to read the graph.
5 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LAIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA BIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
EIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
IIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JCIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JC DIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JC D
HIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JC D
H GIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JC D
H G
KIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JC D
H G
K LIThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JC D
H G
K LF
IThis is a DFS forest.IColored edges are called tree edges .
IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JC D
H G
K LF
IThis is a DFS forest.
IColored edges are called tree edges .IUnused edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A B C D
E F G H
I J K LA B
E
I JC D
H G
K LF
IThis is a DFS forest.
IColored edges are called tree edges .
IUnused edges are called back edges .IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A
B E
I
JC
D
H
G
KLF
IThis is a DFS forest.
ISolid edges are called tree edges .
IDashed edges are called back edges .IBack edges correspond to cycles .
6 / 8

Edge types in DFS forest (undirected)
Example Suppose nodes are visited in lexicographical
A
B E
I
JC
D
H
G
KLF
IThis is a DFS forest.
ISolid edges are called tree edges .
IDashed edges are called back edges .
IBack edges correspond to cycles .
6 / 8

Cycle detection (undirected)
To nd cycles, it is sucient to nd back edges, which can be
done with a simple modication to the Explore procedure.
Explore( G,s,color ,previous )
visited [s] =color
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color ,s)
ifvisited [v]6= 0 and v6=previous then
Output fv; sgis a back edge or \found cycle"
7 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
//preand post are integer arrays of size jVj
//clock is an integer counter starting at 1
Explore( G,s,color )
visited [s] =color
pre[s] =clock
clock =clock + 1
foreach edgefs; vg 2Edo
ifvisited [v] == 0 then
Explore( G,v,color )
post[s] =clock
clock =clock + 1
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF12
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
234
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
345
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
56
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
67891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
789101112
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
1213
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
1314
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
1415
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
1617181920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
192021222324
8 / 8

Pre- and post-visit timestamps (undirected)
We can collect more information during Explore by keeping a
global clock that ticks every time we:
Ivisit a node for the rst time, and
Ileave a node for good.
Example
A
B E
I
JC
D
H
G
KLF1
2
34
5
6
7891011
12
13
14
15
161718
1920212223
24
8 / 8