CMPSC 461, Fall 2025
Programming Language Concepts
Instructor: Dr. Suman Saha
Midterm-I Solutions
September 29, 2025 ||8:10 PM - 10:00 PM
P# Possible Score
1 20
2 16
3 10
4 10
5 10
6 14
Bonus 20
Total 100
This exam is a closed book and closed notes. You may not use any additional materials during the exam.
All electronic devices must be put away. You may have nothing on your desk except this exam, and writing
instruments. Make sure you use a pencil/pen of high contrast and your name, user ID,andstudent ID
areclearly visible andlegible in the space provided. If you fail to do so Gradescope might not process it
correctly. Also please don’t forget to mention your user IDoneach page (inthespace provided). If you are
using the extra sheet or paper to answer your question make sure you mention a note about it under
that particular question.
This exam consists of 6 questions + 1 bonus question (in total 7 questions). The bonus question is 20 marks
making exam total of 100 points (80 points + 20 points for bonus questions).
How bonus question works: The maximum points you can score in this whole exam is 80 points. If you
get all the first 6 six questions correct & you will score 80 points out of 100 points, you will be getting 80
marks (100 %). If you do all 7 questions correctly and score 100 out of 100 marks, you will still be getting
80 marks (100 %). If the total of your attempt in the whole exam is less than 80 points, for example: say 60
pts out of 100 pts, your final score is 60 out of 80 (75%).
Read each question carefully and use your time judiciously. The problems are not ordered by their difficulty.
Also, the examples provided with the questions (if any) are not exhaustive.
Please refer to the last page (appendix) to refer to the rules on how to approach and solve problems related
to first and follow.

User ID (Eg: abc2345):
Problem 1: Regular Expressions [20pts]
1. Write a regular expression for a student’s standard email address that satisfies the following rules:
[7 pts]
• Begins with exactly three lowercase English letters (a–z).
• Followed by exactly four digits, where the first digit cannot be 0.
• Followed by the symbol @.
• The domain must be 3–5 lowercase letters.
• Ends with .edu .
Valid:
dph5402@psu.edu
abc2350@math.edu
Invalid:
ab5402@psu.edu – only 2 letters at the start
abc0350@psu.edu – first digit is 0
abc2350@p.edu – domain too short
abc2350@school.education – must end exactly with .edu
2. Construct a regular expression to match U.S. ZIP codes, which are either: [6 pts]
• Exactly 5 digits, OR
• 5 digits followed by a hyphen and 4 more digits.
Valid:
16802
12345-6789
Invalid:
1234 – too short
123456 – too long
CMPSC461, Fall-2025 |Midterm-I 2 /20

User ID (Eg: abc2345):
3. Construct a regular expression over Σ ={a, b}for strings that contain an even number of a(0,2,4,. . . ).
[7 pts]
Valid:
bb
aabb
babab
Invalid:
a– odd number of a
aba – odd number of a
aaab – odd number of a
Solution
(a)[a-z]{3}[1-9][0-9]{3}@[a-z]{3,5}\.edu
(b)[0-9]5(-[0-9]4)?
(c) b*(ab*ab*)*
CMPSC461, Fall-2025 |Midterm-I 3 /20

User ID (Eg: abc2345):
Problem 2: Finite Automata [16pts]
1. Design a DFA recognizing the string over the alphabet {1,2,3}where the string starts with 3and has
odd number of 1s. [5 pts]
For example, accepted strings: 31,331,31211 ,3122131 ; rejected strings: ϵ,3,311,32211 .
Draw the graph clearly with states and transitions. Mark the start state and all accepting state(s). No
explanation required. No transition table required.
2. Design a NFA recognizing the string over the alphabet {a, b, c}where the string ends with cba.
[6 pts]
For example, accepted strings: cba,acba ,cccba ,cbacba ; rejected strings: ϵ,cbaa ,cbba,cbaba .
Draw the graph clearly with states and transitions. Mark the start state and all accepting state(s). No
explanation required. No transition table required.
3. Convert the following NFA transition table into equivalent DFA transition table using subset con-
struction.
[5 pts]
Only DFA transition table is required. No Automata graph required. No explanation required. Also,
mention the start state and all accepting state(s) in the derived DFA. You can omit the row if no
transitions going out from the state or it cannot be reached from the start state.
NFA State x y z
q0 ϕ {q1}{q0, q2}
q1 {q2} ϕ {q2}
q2 {q0, q1}{q2} ϕ
The start state is q0, and the accepting state is q2.
Solution
1. One correct DFA is shown below:
q0 q1 q232, 3
12, 3
1
2. One correct NFA is shown below:
CMPSC461, Fall-2025 |Midterm-I 4 /20

User ID (Eg: abc2345):
q0 q1 q2 q3a, b, c
c b a
a, b, c
3. The transition table is shown below:
DFA State x y z
q0 ϵ q1q0q2
q1 q2 ϵ q2
q0q2 q0q1q1q2q0q2
q2 q0q1 q2 ϵ
q0q1 q2 q1q0q2
q1q2 q0q1q2q2 q2
q0q1q2 q0q1q2q1q2q0q2
The start state is q0, and the accepting states are q0q2,q2,q1q2, and q0q1q2.
CMPSC461, Fall-2025 |Midterm-I 5 /20

User ID (Eg: abc2345):
——— Extra page for Q2 ———
CMPSC461, Fall-2025 |Midterm-I 6 /20

User ID (Eg: abc2345):
Problem 3: Grammar I [10pts]
Consider the grammar:
1.L={w∈ {a, b, c}∗|wcontains an even number of a’s }. Some valid strings are bbc, caba, aa, abba,
etc.
(a) Provide CFG for the language mentioned above. [4 pts]
(b) Using grammar generated in part a), provide the left-most derivation for string baa. [3 pts]
2.L={0n1m0n|n≥1, m≥0}. Some valid strings in the language are 010, 00100, 00011000, etc.
(a) Provide a CFG for the language. [3 pts]
Solution
1. (a)
S→aA|bS|cS|ϵ
A→aS|bA|cA
(b)S⇒bS⇒baA⇒baaS⇒baaϵ=baa
2.
S→0S0|0A0
A→1A|ϵ
CMPSC461, Fall-2025 |Midterm-I 7 /20

User ID (Eg: abc2345):
Problem 4: Grammar II [10pts]
Convert each of the following regular expressions into an equivalent CFG using BNF notation. Your gram-
mar should be unambiguous and use a minimal number of production rules. To abbreviate ranges of con-
secutive characters, you can use the syntax a| ··· | z.
1.\$[1-9][0-9]?[0-9]?(,[0-9] {3})*\.[0-9][0-9] [5 pts]
Matches strings like $999,888.77 and$1,2345.67 and$1.75 but not $9999,888.77 or
$12,34.56 or1.75 .
2.(0|-?[1-9][0-9] *)(\.[0-9] *[1-9])?e(0|-?[1-9][0-9] *) [5 pts]
Matches strings like 0e0 and-14.5e-5 and1.234e10 but not 01e0 or1e01 or1.2000e3
Solution
1.S→$D1N0N1.D0D0
N0→D0D0|D0|ϵ
N1→,D0D0D0N1|ϵ
D0→0| ··· | 9
D1→1| ··· | 9
2.S→N0N1eN0
N0→0| −D1Dn|D1Dn
N1→.DnD1|ϵ
Dn→D0Dn|ϵ
D0→0| ··· | 9
D1→1| ··· | 9
CMPSC461, Fall-2025 |Midterm-I 8 /20

User ID (Eg: abc2345):
——— Extra page for Q4 ———
CMPSC461, Fall-2025 |Midterm-I 9 /20

User ID (Eg: abc2345):
Problem 5: Name, Scope, and Binding I [10pts]
Consider the following pseudo-code:
int val = 1;
void processor() {
print(val);
}
void recursive_func( int n,bool shadow) {
if(n == 0) {
processor();
return ;
}
if(shadow) {
int val = n *10;
recursive_func(n - 1, false );
}else {
recursive_func(n - 1, true );
}
}
void main() {
recursive_func(3, true );
}
(a) Draw a diagram of the runtime stack at the exact moment the processor() function is called.
For each activation frame, clearly label its static link anddynamic link . [4 pts]
(b) What is the output of this program, assuming the language uses: [6 pts]
i. Static scoping?
ii. Dynamic scoping?
Solution
(a)Runtime Stack at processor() call
CMPSC461, Fall-2025 |Midterm-I 10 /20

User ID (Eg: abc2345):
processor()
recursive func(0,false)
recursive func(1,true)
local val=10
recursive func(2,false)
recursive func(3,true)
local val=30
Main()Static Links
Dynamic Links
(b)Program Outputs
i. Static scoping: 1
ii. Dynamic scoping: 10
CMPSC461, Fall-2025 |Midterm-I 11 /20

User ID (Eg: abc2345):
——— Extra page for Q5 ———
CMPSC461, Fall-2025 |Midterm-I 12 /20

User ID (Eg: abc2345):
Problem 6: Name, Scope and Binding II [14pts]
Consider the following pseudo-code, assuming dynamic scoping rules:
1typedef void (*FuncPtr)();
2
3void printer() {
4 print(x);
5}
6
7FuncPtr outer() {
8 int x = 20;
9
10 FuncPtr inner() {
11 int x = 40;
12 return printer;
13 }
14
15 return inner();
16}
17
18void main() {
19 FuncPtr f = outer();
20 f();
21}
(A) Draw the symbol tables for the scopes global ,printer ,outer , andinner . [5 pts]
(B)What is the output under shallow binding ? Explain the resolution of x. [5 pts]
(C) What is the output under deep binding ? Which environment is captured and used? [4 pts]
Solution
(A) Symbol Tables
global
name kind
printer func
outer func
main funcprinter
name kind
outer
name kind
x id
inner funcinner
name kind
x id
CMPSC461, Fall-2025 |Midterm-I 13 /20

User ID (Eg: abc2345):
(B) Shallow binding output: Error: Unbound variable ‘x‘.
Explanation: The call ‘f()‘ (which points to ‘printer‘) happens in ‘main‘. With shallow binding, ‘x‘
is sought at the call site . The call stack is ‘main - >printer‘. The search checks ‘printer‘ (no ‘x‘),
then its caller ‘main‘ (no ‘x‘), and then the global scope (no ‘x‘). Since no binding for ‘x‘ is found
along the dynamic chain, it is an error.
(C) Deep binding output: 40.
Explanation: The reference to ‘printer‘ is created when ‘inner()‘ returns. Deep binding captures
the environment of ‘inner()‘ at that moment, which contains the binding ‘x = 40‘. When ‘printer‘ is
called later from ‘main‘, it uses this captured environment (its closure) to find ‘x‘, printing ‘40‘.
CMPSC461, Fall-2025 |Midterm-I 14 /20

User ID (Eg: abc2345):
——— Extra page for Q6 ———
CMPSC461, Fall-2025 |Midterm-I 15 /20

User ID (Eg: abc2345):
Problem 7: Bonus [20pts]
1. (True or False): In a context-free grammar, the left-hand side of every production rule must consist
of exactly one non-terminal symbol. [2 pts]
2. What is a production rule in a context-free grammar? Write one example and explain its parts.
[2 pts]
3. Consider the grammar:
S→A C
A→a|ϵ
C→c C|d
(a) Compute the FIRST andFOLLOW sets for S, A, C . [7 pts]
(b) Construct the LL(1) parsing table and state whether the grammar is LL(1). [9 pts]
Solution
1. True. By definition, a CFG rule has a single non-terminal on the left-hand side, while the right-hand
side may contain terminals, non-terminals, or ϵ(the empty string).
2. A production rule specifies how a non-terminal can be replaced by a sequence of terminals and/or
non-terminals. It has the form A→α, where:
•Ais a non-terminal (left-hand side).
•αis a string of terminals, non-terminals, or ϵ(right-hand side).
Example: E→E+T
Here, Eis the non-terminal being defined, and E+Tshows how it can be expanded.
3. (a) FIRST sets: FIRST (A) ={a, ϵ},FIRST (C) ={c, d},FIRST (S) ={a, c, d}.
FOLLOW sets: FOLLOW (S) ={$},FOLLOW (A) ={c, d},FOLLOW (C) ={$}.
(b) Parsing table:
Non-terminal a c d $
S S→AC S→AC S→AC
A A→a A→ϵ A→ϵ
C C→cC C→d
No conflicts ⇒Grammar is LL(1).
CMPSC461, Fall-2025 |Midterm-I 16 /20

User ID (Eg: abc2345):
——— Extra page for Q7 ———
CMPSC461, Fall-2025 |Midterm-I 17 /20

User ID (Eg: abc2345):
——— Extra page if needed. ———
CMPSC461, Fall-2025 |Midterm-I 18 /20

User ID (Eg: abc2345):
——— Extra page if needed. ———
CMPSC461, Fall-2025 |Midterm-I 19 /20

User ID (Eg: abc2345):
Appendix
First(C)
FIRST(C) for a grammar symbol C is the set of terminals that begin the strings derivable from C. Formally,
it is defined as:
First(C) ={t|C→∗tα} ∪ {ε|C→∗ε}
Follow(C)
Follow(C) is defined to be the set of terminals that can appear immediately to the right of Non-Terminal C
in some sentential form.
Rules:
• If C is the start symbol, then $ ∈Follow(C).
• IfC→AB, then First (B)⊆Follow (A)and Follow (C)⊆Follow (B).
• Also, if B→∗ε, then Follow (C)⊆Follow (A).
Constructing LL(1) Parsing Table
Construct a parsing table Tfor CFG Gusing the following procedure:
For each production A→αinGdo:
1. For each terminal t∈First(α)do
•T[A, t] =α
2. If ε∈First(α), for each t∈Follow (A)do
•T[A, t] =α
3. If ε∈First(α)and $∈Follow (A)do
•T[A,$] =α
CMPSC461, Fall-2025 |Midterm-I 20 /20